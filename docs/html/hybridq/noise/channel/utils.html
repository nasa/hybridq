<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>hybridq.noise.channel.utils API documentation</title>
<meta name="description" content="Authors: Salvatore Mandra (salvatore.mandra@nasa.gov),
Jeffrey Marshall (jeffrey.s.marshall@nasa.gov) …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>hybridq.noise.channel.utils</code></h1>
</header>
<section id="section-intro">
<p>Authors: Salvatore Mandra (salvatore.mandra@nasa.gov),
Jeffrey Marshall (jeffrey.s.marshall@nasa.gov)</p>
<p>Copyright © 2021, United States Government, as represented by the Administrator
of the National Aeronautics and Space Administration. All rights reserved.</p>
<p>The HybridQ: A Hybrid Simulator for Quantum Circuits platform is licensed under
the Apache License, Version 2.0 (the "License"); you may not use this file
except in compliance with the License. You may obtain a copy of the License at
<a href="http://www.apache.org/licenses/LICENSE-2.0.">http://www.apache.org/licenses/LICENSE-2.0.</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed
under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Authors: Salvatore Mandra (salvatore.mandra@nasa.gov),
         Jeffrey Marshall (jeffrey.s.marshall@nasa.gov)

Copyright © 2021, United States Government, as represented by the Administrator
of the National Aeronautics and Space Administration. All rights reserved.

The HybridQ: A Hybrid Simulator for Quantum Circuits platform is licensed under
the Apache License, Version 2.0 (the &#34;License&#34;); you may not use this file
except in compliance with the License. You may obtain a copy of the License at
http://www.apache.org/licenses/LICENSE-2.0.

Unless required by applicable law or agreed to in writing, software distributed
under the License is distributed on an &#34;AS IS&#34; BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.
&#34;&#34;&#34;

from __future__ import annotations
import numpy as np


def is_dm(rho: np.ndarray, atol=1e-6) -&gt; bool:
    &#34;&#34;&#34;
    check if the given input a valid density matrix.
    &#34;&#34;&#34;
    rho = np.asarray(rho)
    d = int(np.sqrt(np.prod(rho.shape)))
    rho_full = np.reshape(rho, (d, d))

    hc = np.allclose(rho_full, rho_full.T.conj(), atol=atol)
    tp = np.isclose(np.trace(rho_full), 1, atol=atol)

    apprx_gtr = lambda y, x: np.real(y) &gt;= x or np.isclose(y, x, atol=atol)
    ev = np.linalg.eigvals(rho_full)
    psd = np.all([apprx_gtr(e, 0) for e in ev])

    return (hc and tp and psd)


def ptrace(state: np.ndarray,
           keep: {int, list[int]},
           dims: {int, list[int]} = None) -&gt; np.ndarray:
    &#34;&#34;&#34;
    compute the partial trace of a pure state (vector) or density matrix.
    state: np.array
        One dimensional for pure state e.g. np.array([1,0,0,0])
        or two dimensional for density matrix e.g. np.array([[1,0],[0,0]])
    keep: list of int
        the qubits we want to keep (all others traced out).
        Can also specify a single int if only keeping one qubit.
    dims: list of int, optional
        List of qudit dimensions respecting the ordering of `state`.
        Number of qubits is `len(dims)`, and full Hilbert space
        dimension is `product(dims)`.
        If unspecified, assumes 2 for all.
    Returns the density matrix of the remaining qubits.
    &#34;&#34;&#34;
    state = np.asarray(state)
    if len(state.shape) not in (1, 2):
        raise ValueError(&#39;should be pure state (one dimensional) &#39;
                         &#39;or density matrix (two dimensional). &#39;
                         f&#39;Received dimension {len(state.shape)}&#39;)

    # pure state or not
    pure = len(state.shape) == 1
    if not pure and state.shape[0] != state.shape[1]:
        raise ValueError(&#39;invalid state input.&#39;)

    full_dim = np.prod(state.shape[0])
    if dims is not None and full_dim != np.prod(dims):
        raise ValueError(&#39;specified dimensions inconsistent with state&#39;)

    n_qubits = np.log2(full_dim) if dims is None else len(dims)
    if np.isclose(n_qubits, round(n_qubits)):
        n_qubits = int(round(n_qubits))
    else:
        raise ValueError(&#39;invalid state size&#39;)

    keep = [keep] if isinstance(keep, int) else list(keep)
    if not np.all([q in range(n_qubits)
                   for q in keep]) or len(keep) &gt;= n_qubits:
        raise ValueError(&#39;invalid axes&#39;)
    if dims is None:
        dims = [2] * n_qubits

    # dimensions of qubits we keep
    final_dims = [dims[i] for i in keep]
    final_dim = np.prod(final_dims)
    # dimensions to trace out
    drop_dim = int(round(full_dim / final_dim))

    if pure:
        state = state.reshape(dims)
        perm = keep + [q for q in range(n_qubits) if q not in keep]
        state = np.transpose(state, perm).reshape(final_dim, drop_dim)
        return np.einsum(&#39;ij,kj-&gt;ik&#39;, state, state.conj())
    else:
        # now we have to redefine things in case of a density matrix
        # basically we double the sizes
        density_dims = dims + dims
        keep += [q + n_qubits for q in keep]
        perm = keep + [q for q in range(2 * n_qubits) if q not in keep]

        state = state.reshape(density_dims)
        state = np.transpose(state, perm)
        state = state.reshape((final_dim, final_dim, drop_dim, drop_dim))
        return np.einsum(&#39;ijkk-&gt;ij&#39;, state)


def is_channel(channel: MatrixChannel,
               atol=1e-8,
               order: tuple[any, ...] = None,
               **kwargs) -&gt; bool:
    &#34;&#34;&#34;
    Checks using the Choi matrix whether or not `channel` defines
    a valid quantum channel.
    That is, we check it is a valid CPTP map.

    Parameters
    ----------
    atol: float, optional
        absolute tolerance to use for determining channel is CPTP.
    order: tuple[any, ...], optional
        If provided, Kraus&#39; map is ordered accordingly to `order`.
        See `MatrixChannel.map()`
    kwargs: kwargs for `MatrixChannel.map()`
    &#34;&#34;&#34;
    C = choi_matrix(channel, order, **kwargs)
    dim = _channel_dim(channel)

    # trace preserving
    tp = np.isclose(C.trace(), dim, atol=atol)

    # hermiticity preserving
    hp = np.allclose(C, C.conj().T, atol=atol)

    # completely positive
    apprx_gtr = lambda e, x: np.real(e) &gt;= x or np.isclose(e, x, atol=atol)
    cp = np.all([
        apprx_gtr(e, 0) and np.isclose(np.imag(e), 0, atol=atol)
        for e in np.linalg.eigvals(C)
    ])

    return tp and hp and cp


def choi_matrix(channel: MatrixChannel,
                order: tuple[any, ...] = None,
                **kwargs) -&gt; np.ndarray:
    &#34;&#34;&#34;
    return the Choi matrix for channel, of shape (d**2, d**2)
    for a d-dimensional Hilbert space.

    The channel can be applied as:
    Lambda(rho) = Tr_0[ (I \otimes rho^T) C]
    where C is the Choi matrix.

    Parameters
    ----------
    order: tuple[any, ...], optional
        If provided, Kraus&#39; map is ordered accordingly to `order`.
        See `MatrixChannel.map()`
    kwargs: kwargs for `MatrixChannel.map()`
    &#34;&#34;&#34;

    op = channel.map(order, **kwargs)
    d = _channel_dim(channel)

    C = np.zeros((d**2, d**2), dtype=complex)
    for ij in range(d**2):
        Eij = np.zeros(d**2)
        Eij[ij] = 1
        map = op @ Eij  # using vectorization
        C += np.kron(Eij.reshape((d, d)), map.reshape((d, d)))

    return C


def _channel_dim(channel):
    # dimension (assume all Kraus&#39; have same shape)
    return channel.Kraus.gates[0][0].matrix().shape[0]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="hybridq.noise.channel.utils.choi_matrix"><code class="name flex">
<span>def <span class="ident">choi_matrix</span></span>(<span>channel: MatrixChannel, order: tuple[any, ...] = None, **kwargs) ‑> np.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>return the Choi matrix for channel, of shape (d<strong>2, d</strong>2)
for a d-dimensional Hilbert space.</p>
<p>The channel can be applied as:
Lambda(rho) = Tr_0[ (I \otimes rho^T) C]
where C is the Choi matrix.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>order</code></strong> :&ensp;<code>tuple[any, &hellip;]</code>, optional</dt>
<dd>If provided, Kraus' map is ordered accordingly to <code>order</code>.
See <code>MatrixChannel.map()</code></dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>kwargs for </code>MatrixChannel.map()``</dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def choi_matrix(channel: MatrixChannel,
                order: tuple[any, ...] = None,
                **kwargs) -&gt; np.ndarray:
    &#34;&#34;&#34;
    return the Choi matrix for channel, of shape (d**2, d**2)
    for a d-dimensional Hilbert space.

    The channel can be applied as:
    Lambda(rho) = Tr_0[ (I \otimes rho^T) C]
    where C is the Choi matrix.

    Parameters
    ----------
    order: tuple[any, ...], optional
        If provided, Kraus&#39; map is ordered accordingly to `order`.
        See `MatrixChannel.map()`
    kwargs: kwargs for `MatrixChannel.map()`
    &#34;&#34;&#34;

    op = channel.map(order, **kwargs)
    d = _channel_dim(channel)

    C = np.zeros((d**2, d**2), dtype=complex)
    for ij in range(d**2):
        Eij = np.zeros(d**2)
        Eij[ij] = 1
        map = op @ Eij  # using vectorization
        C += np.kron(Eij.reshape((d, d)), map.reshape((d, d)))

    return C</code></pre>
</details>
</dd>
<dt id="hybridq.noise.channel.utils.is_channel"><code class="name flex">
<span>def <span class="ident">is_channel</span></span>(<span>channel: MatrixChannel, atol=1e-08, order: tuple[any, ...] = None, **kwargs) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks using the Choi matrix whether or not <code>channel</code> defines
a valid quantum channel.
That is, we check it is a valid CPTP map.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>atol</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>absolute tolerance to use for determining channel is CPTP.</dd>
<dt><strong><code>order</code></strong> :&ensp;<code>tuple[any, &hellip;]</code>, optional</dt>
<dd>If provided, Kraus' map is ordered accordingly to <code>order</code>.
See <code>MatrixChannel.map()</code></dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>kwargs for </code>MatrixChannel.map()``</dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_channel(channel: MatrixChannel,
               atol=1e-8,
               order: tuple[any, ...] = None,
               **kwargs) -&gt; bool:
    &#34;&#34;&#34;
    Checks using the Choi matrix whether or not `channel` defines
    a valid quantum channel.
    That is, we check it is a valid CPTP map.

    Parameters
    ----------
    atol: float, optional
        absolute tolerance to use for determining channel is CPTP.
    order: tuple[any, ...], optional
        If provided, Kraus&#39; map is ordered accordingly to `order`.
        See `MatrixChannel.map()`
    kwargs: kwargs for `MatrixChannel.map()`
    &#34;&#34;&#34;
    C = choi_matrix(channel, order, **kwargs)
    dim = _channel_dim(channel)

    # trace preserving
    tp = np.isclose(C.trace(), dim, atol=atol)

    # hermiticity preserving
    hp = np.allclose(C, C.conj().T, atol=atol)

    # completely positive
    apprx_gtr = lambda e, x: np.real(e) &gt;= x or np.isclose(e, x, atol=atol)
    cp = np.all([
        apprx_gtr(e, 0) and np.isclose(np.imag(e), 0, atol=atol)
        for e in np.linalg.eigvals(C)
    ])

    return tp and hp and cp</code></pre>
</details>
</dd>
<dt id="hybridq.noise.channel.utils.is_dm"><code class="name flex">
<span>def <span class="ident">is_dm</span></span>(<span>rho: np.ndarray, atol=1e-06) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>check if the given input a valid density matrix.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_dm(rho: np.ndarray, atol=1e-6) -&gt; bool:
    &#34;&#34;&#34;
    check if the given input a valid density matrix.
    &#34;&#34;&#34;
    rho = np.asarray(rho)
    d = int(np.sqrt(np.prod(rho.shape)))
    rho_full = np.reshape(rho, (d, d))

    hc = np.allclose(rho_full, rho_full.T.conj(), atol=atol)
    tp = np.isclose(np.trace(rho_full), 1, atol=atol)

    apprx_gtr = lambda y, x: np.real(y) &gt;= x or np.isclose(y, x, atol=atol)
    ev = np.linalg.eigvals(rho_full)
    psd = np.all([apprx_gtr(e, 0) for e in ev])

    return (hc and tp and psd)</code></pre>
</details>
</dd>
<dt id="hybridq.noise.channel.utils.ptrace"><code class="name flex">
<span>def <span class="ident">ptrace</span></span>(<span>state: np.ndarray, keep: {int, list[int]}, dims: {int, list[int]} = None) ‑> np.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>compute the partial trace of a pure state (vector) or density matrix.
state: np.array
One dimensional for pure state e.g. np.array([1,0,0,0])
or two dimensional for density matrix e.g. np.array([[1,0],[0,0]])
keep: list of int
the qubits we want to keep (all others traced out).
Can also specify a single int if only keeping one qubit.
dims: list of int, optional
List of qudit dimensions respecting the ordering of <code>state</code>.
Number of qubits is <code>len(dims)</code>, and full Hilbert space
dimension is <code>product(dims)</code>.
If unspecified, assumes 2 for all.
Returns the density matrix of the remaining qubits.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ptrace(state: np.ndarray,
           keep: {int, list[int]},
           dims: {int, list[int]} = None) -&gt; np.ndarray:
    &#34;&#34;&#34;
    compute the partial trace of a pure state (vector) or density matrix.
    state: np.array
        One dimensional for pure state e.g. np.array([1,0,0,0])
        or two dimensional for density matrix e.g. np.array([[1,0],[0,0]])
    keep: list of int
        the qubits we want to keep (all others traced out).
        Can also specify a single int if only keeping one qubit.
    dims: list of int, optional
        List of qudit dimensions respecting the ordering of `state`.
        Number of qubits is `len(dims)`, and full Hilbert space
        dimension is `product(dims)`.
        If unspecified, assumes 2 for all.
    Returns the density matrix of the remaining qubits.
    &#34;&#34;&#34;
    state = np.asarray(state)
    if len(state.shape) not in (1, 2):
        raise ValueError(&#39;should be pure state (one dimensional) &#39;
                         &#39;or density matrix (two dimensional). &#39;
                         f&#39;Received dimension {len(state.shape)}&#39;)

    # pure state or not
    pure = len(state.shape) == 1
    if not pure and state.shape[0] != state.shape[1]:
        raise ValueError(&#39;invalid state input.&#39;)

    full_dim = np.prod(state.shape[0])
    if dims is not None and full_dim != np.prod(dims):
        raise ValueError(&#39;specified dimensions inconsistent with state&#39;)

    n_qubits = np.log2(full_dim) if dims is None else len(dims)
    if np.isclose(n_qubits, round(n_qubits)):
        n_qubits = int(round(n_qubits))
    else:
        raise ValueError(&#39;invalid state size&#39;)

    keep = [keep] if isinstance(keep, int) else list(keep)
    if not np.all([q in range(n_qubits)
                   for q in keep]) or len(keep) &gt;= n_qubits:
        raise ValueError(&#39;invalid axes&#39;)
    if dims is None:
        dims = [2] * n_qubits

    # dimensions of qubits we keep
    final_dims = [dims[i] for i in keep]
    final_dim = np.prod(final_dims)
    # dimensions to trace out
    drop_dim = int(round(full_dim / final_dim))

    if pure:
        state = state.reshape(dims)
        perm = keep + [q for q in range(n_qubits) if q not in keep]
        state = np.transpose(state, perm).reshape(final_dim, drop_dim)
        return np.einsum(&#39;ij,kj-&gt;ik&#39;, state, state.conj())
    else:
        # now we have to redefine things in case of a density matrix
        # basically we double the sizes
        density_dims = dims + dims
        keep += [q + n_qubits for q in keep]
        perm = keep + [q for q in range(2 * n_qubits) if q not in keep]

        state = state.reshape(density_dims)
        state = np.transpose(state, perm)
        state = state.reshape((final_dim, final_dim, drop_dim, drop_dim))
        return np.einsum(&#39;ijkk-&gt;ij&#39;, state)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="hybridq.noise.channel" href="index.html">hybridq.noise.channel</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="hybridq.noise.channel.utils.choi_matrix" href="#hybridq.noise.channel.utils.choi_matrix">choi_matrix</a></code></li>
<li><code><a title="hybridq.noise.channel.utils.is_channel" href="#hybridq.noise.channel.utils.is_channel">is_channel</a></code></li>
<li><code><a title="hybridq.noise.channel.utils.is_dm" href="#hybridq.noise.channel.utils.is_dm">is_dm</a></code></li>
<li><code><a title="hybridq.noise.channel.utils.ptrace" href="#hybridq.noise.channel.utils.ptrace">ptrace</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>