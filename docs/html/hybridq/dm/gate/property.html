<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>hybridq.dm.gate.property API documentation</title>
<meta name="description" content="Author: Salvatore Mandra (salvatore.mandra@nasa.gov) …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>hybridq.dm.gate.property</code></h1>
</header>
<section id="section-intro">
<p>Author: Salvatore Mandra (salvatore.mandra@nasa.gov)</p>
<p>Copyright © 2021, United States Government, as represented by the Administrator
of the National Aeronautics and Space Administration. All rights reserved.</p>
<p>The HybridQ: A Hybrid Simulator for Quantum Circuits platform is licensed under
the Apache License, Version 2.0 (the "License"); you may not use this file
except in compliance with the License. You may obtain a copy of the License at
<a href="http://www.apache.org/licenses/LICENSE-2.0.">http://www.apache.org/licenses/LICENSE-2.0.</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed
under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Author: Salvatore Mandra (salvatore.mandra@nasa.gov)

Copyright © 2021, United States Government, as represented by the Administrator
of the National Aeronautics and Space Administration. All rights reserved.

The HybridQ: A Hybrid Simulator for Quantum Circuits platform is licensed under
the Apache License, Version 2.0 (the &#34;License&#34;); you may not use this file
except in compliance with the License. You may obtain a copy of the License at
http://www.apache.org/licenses/LICENSE-2.0.

Unless required by applicable law or agreed to in writing, software distributed
under the License is distributed on an &#34;AS IS&#34; BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.
&#34;&#34;&#34;

from __future__ import annotations
from hybridq.base import generate, staticvars, compare, requires, __Base__
from hybridq.base.property import Tuple
import numpy as np


class BaseTupleSuperGate(Tuple):
    &#34;&#34;&#34;
    Gate defined as a tuple of gates.
    &#34;&#34;&#34;

    @property
    def qubits(self) -&gt; tuple[tuple[any, ...], tuple[any, ...]]:
        from hybridq.gate import BaseGate

        # Define flatten
        def _unique_flatten(l):
            from hybridq.utils import sort
            return tuple(sort(set(y for x in l for y in x)))

        # Get qubits
        def _get_qubits(gate):
            if isinstance(gate, BaseGate):
                # Get qubits
                qubits = gate.qubits
                return (qubits, qubits)
            else:
                return gate.qubits

        # Get all qubits
        _qubits = tuple(
            _get_qubits(g) if g.provides(&#39;qubits&#39;) else (None, None)
            for g in self)

        # Split in left and right qubits
        try:
            _lq, _rq = map(tuple, zip(*_qubits))
        except ValueError:
            return tuple(), tuple()

        # If any none is present, set to None
        _lq = None if any(q is None for q in _lq) else _unique_flatten(_lq)
        _rq = None if any(q is None for q in _rq) else _unique_flatten(_rq)

        # Return qubits
        return (_lq, _rq)

    @property
    def n_qubits(self) -&gt; int:
        # Get left and right qubits
        _lq, _rq = self.qubits
        return None if _lq is None else len(_lq), None if _rq is None else len(
            _rq)


@requires(&#39;qubits,Matrix&#39;)
class Map(__Base__):

    def map(self, order: iter[any] = None):
        &#34;&#34;&#34;
        Return map.

        Parameters
        ----------
        order: tuple[any, ...], optional
            If provided, Kraus&#39; map is ordered accordingly to `order`.
        &#34;&#34;&#34;
        # Get left and right qubits
        l_qubits, r_qubits = self.qubits

        # Get order
        if order is not None:
            from hybridq.utils import sort

            # Get order
            order = tuple(order)

            try:
                # Split
                l_order, r_order = order

                # Convert to tuples
                l_order = tuple(l_order)
                r_order = tuple(r_order)

                # Check that qubits are consistent
                if sort(l_order) != sort(l_qubits) or sort(r_order) != sort(
                        r_qubits):
                    raise RuntimeError(&#34;Something went wrong.&#34;)

                # Get order
                order = (l_order, r_order)
            except:
                if l_qubits != r_qubits or sort(order) != sort(l_qubits):
                    raise ValueError(
                        &#34;&#39;order&#39; is not a valid permutation of qubits.&#34;)

                # Get order
                order = (order, order)

        # Get Matrix representing the map
        _U = self.Matrix

        # Transpose if order is provided
        if order is not None and (order[0] != self.l_qubits or
                                  order[1] != self.r_qubits):
            from hybridq.gate import MatrixGate

            # Get gate
            _g = MatrixGate(_U,
                            qubits=tuple((0, q) for q in l_qubits) + tuple(
                                (1, q) for q in r_qubits),
                            copy=False)

            # Transpose
            _U = _g.matrix(order=tuple((0, q) for q in order[0]) + tuple(
                (1, q) for q in order[1]))

        # Return map
        return _U

    def isclose(self, gate: Map, atol: float = 1e-8):

        # If gate is not a SuperGate or they qubits differ, they are different
        if not isinstance(gate, Map) or self.qubits != gate.qubits:
            return False

        # Get matrices
        _U1 = self.map(order=self.qubits)
        _U2 = gate.map(order=self.qubits)

        # Check
        return np.allclose(_U1, _U2, atol=atol)

    def commutes_with(self, gate: Map, atol: float = 1e-7):
        from hybridq.gate import MatrixGate

        # Gate must be a map
        if not isinstance(gate, Map):
            raise ValueError(
                f&#34;Cannot compute commutation between &#39;Map&#39; and &#39;{type(gate).__name__}&#39;&#34;
            )

        # Get gates
        g1 = MatrixGate(self.Matrix,
                        qubits=[(0, q) for q in self.l_qubits] +
                        [(1, q) for q in self.r_qubits],
                        copy=False)
        g2 = MatrixGate(gate.Matrix,
                        qubits=[(0, q) for q in gate.l_qubits] +
                        [(1, q) for q in gate.r_qubits],
                        copy=False)

        # Return if they commute
        return g1.commutes_with(g2, atol=atol)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="hybridq.dm.gate.property.BaseTupleSuperGate"><code class="flex name class">
<span>class <span class="ident">BaseTupleSuperGate</span></span>
<span>(</span><span>elements=(), tags=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Gate defined as a tuple of gates.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseTupleSuperGate(Tuple):
    &#34;&#34;&#34;
    Gate defined as a tuple of gates.
    &#34;&#34;&#34;

    @property
    def qubits(self) -&gt; tuple[tuple[any, ...], tuple[any, ...]]:
        from hybridq.gate import BaseGate

        # Define flatten
        def _unique_flatten(l):
            from hybridq.utils import sort
            return tuple(sort(set(y for x in l for y in x)))

        # Get qubits
        def _get_qubits(gate):
            if isinstance(gate, BaseGate):
                # Get qubits
                qubits = gate.qubits
                return (qubits, qubits)
            else:
                return gate.qubits

        # Get all qubits
        _qubits = tuple(
            _get_qubits(g) if g.provides(&#39;qubits&#39;) else (None, None)
            for g in self)

        # Split in left and right qubits
        try:
            _lq, _rq = map(tuple, zip(*_qubits))
        except ValueError:
            return tuple(), tuple()

        # If any none is present, set to None
        _lq = None if any(q is None for q in _lq) else _unique_flatten(_lq)
        _rq = None if any(q is None for q in _rq) else _unique_flatten(_rq)

        # Return qubits
        return (_lq, _rq)

    @property
    def n_qubits(self) -&gt; int:
        # Get left and right qubits
        _lq, _rq = self.qubits
        return None if _lq is None else len(_lq), None if _rq is None else len(
            _rq)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hybridq.base.property.Tuple" href="../../base/property.html#hybridq.base.property.Tuple">Tuple</a></li>
<li><a title="hybridq.base.property.Tags" href="../../base/property.html#hybridq.base.property.Tags">Tags</a></li>
<li>hybridq.base.base.__Base__</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="hybridq.dm.gate.property.BaseTupleSuperGate.n_qubits"><code class="name">var <span class="ident">n_qubits</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_qubits(self) -&gt; int:
    # Get left and right qubits
    _lq, _rq = self.qubits
    return None if _lq is None else len(_lq), None if _rq is None else len(
        _rq)</code></pre>
</details>
</dd>
<dt id="hybridq.dm.gate.property.BaseTupleSuperGate.qubits"><code class="name">var <span class="ident">qubits</span> : tuple[tuple[any, ...], tuple[any, ...]]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def qubits(self) -&gt; tuple[tuple[any, ...], tuple[any, ...]]:
    from hybridq.gate import BaseGate

    # Define flatten
    def _unique_flatten(l):
        from hybridq.utils import sort
        return tuple(sort(set(y for x in l for y in x)))

    # Get qubits
    def _get_qubits(gate):
        if isinstance(gate, BaseGate):
            # Get qubits
            qubits = gate.qubits
            return (qubits, qubits)
        else:
            return gate.qubits

    # Get all qubits
    _qubits = tuple(
        _get_qubits(g) if g.provides(&#39;qubits&#39;) else (None, None)
        for g in self)

    # Split in left and right qubits
    try:
        _lq, _rq = map(tuple, zip(*_qubits))
    except ValueError:
        return tuple(), tuple()

    # If any none is present, set to None
    _lq = None if any(q is None for q in _lq) else _unique_flatten(_lq)
    _rq = None if any(q is None for q in _rq) else _unique_flatten(_rq)

    # Return qubits
    return (_lq, _rq)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hybridq.base.property.Tuple" href="../../base/property.html#hybridq.base.property.Tuple">Tuple</a></b></code>:
<ul class="hlist">
<li><code><a title="hybridq.base.property.Tuple.flatten" href="../../base/property.html#hybridq.base.property.Tuple.flatten">flatten</a></code></li>
<li><code><a title="hybridq.base.property.Tuple.remove_tag" href="../../base/property.html#hybridq.base.property.Tags.remove_tag">remove_tag</a></code></li>
<li><code><a title="hybridq.base.property.Tuple.remove_tags" href="../../base/property.html#hybridq.base.property.Tags.remove_tags">remove_tags</a></code></li>
<li><code><a title="hybridq.base.property.Tuple.set_tags" href="../../base/property.html#hybridq.base.property.Tags.set_tags">set_tags</a></code></li>
<li><code><a title="hybridq.base.property.Tuple.update_tags" href="../../base/property.html#hybridq.base.property.Tags.update_tags">update_tags</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="hybridq.dm.gate.property.Map"><code class="flex name class">
<span>class <span class="ident">Map</span></span>
</code></dt>
<dd>
<div class="desc"><p>Basic features.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Map(__Base__):

    def map(self, order: iter[any] = None):
        &#34;&#34;&#34;
        Return map.

        Parameters
        ----------
        order: tuple[any, ...], optional
            If provided, Kraus&#39; map is ordered accordingly to `order`.
        &#34;&#34;&#34;
        # Get left and right qubits
        l_qubits, r_qubits = self.qubits

        # Get order
        if order is not None:
            from hybridq.utils import sort

            # Get order
            order = tuple(order)

            try:
                # Split
                l_order, r_order = order

                # Convert to tuples
                l_order = tuple(l_order)
                r_order = tuple(r_order)

                # Check that qubits are consistent
                if sort(l_order) != sort(l_qubits) or sort(r_order) != sort(
                        r_qubits):
                    raise RuntimeError(&#34;Something went wrong.&#34;)

                # Get order
                order = (l_order, r_order)
            except:
                if l_qubits != r_qubits or sort(order) != sort(l_qubits):
                    raise ValueError(
                        &#34;&#39;order&#39; is not a valid permutation of qubits.&#34;)

                # Get order
                order = (order, order)

        # Get Matrix representing the map
        _U = self.Matrix

        # Transpose if order is provided
        if order is not None and (order[0] != self.l_qubits or
                                  order[1] != self.r_qubits):
            from hybridq.gate import MatrixGate

            # Get gate
            _g = MatrixGate(_U,
                            qubits=tuple((0, q) for q in l_qubits) + tuple(
                                (1, q) for q in r_qubits),
                            copy=False)

            # Transpose
            _U = _g.matrix(order=tuple((0, q) for q in order[0]) + tuple(
                (1, q) for q in order[1]))

        # Return map
        return _U

    def isclose(self, gate: Map, atol: float = 1e-8):

        # If gate is not a SuperGate or they qubits differ, they are different
        if not isinstance(gate, Map) or self.qubits != gate.qubits:
            return False

        # Get matrices
        _U1 = self.map(order=self.qubits)
        _U2 = gate.map(order=self.qubits)

        # Check
        return np.allclose(_U1, _U2, atol=atol)

    def commutes_with(self, gate: Map, atol: float = 1e-7):
        from hybridq.gate import MatrixGate

        # Gate must be a map
        if not isinstance(gate, Map):
            raise ValueError(
                f&#34;Cannot compute commutation between &#39;Map&#39; and &#39;{type(gate).__name__}&#39;&#34;
            )

        # Get gates
        g1 = MatrixGate(self.Matrix,
                        qubits=[(0, q) for q in self.l_qubits] +
                        [(1, q) for q in self.r_qubits],
                        copy=False)
        g2 = MatrixGate(gate.Matrix,
                        qubits=[(0, q) for q in gate.l_qubits] +
                        [(1, q) for q in gate.r_qubits],
                        copy=False)

        # Return if they commute
        return g1.commutes_with(g2, atol=atol)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>hybridq.base.base.__Base__</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="hybridq.dm.gate.property.Map.commutes_with"><code class="name flex">
<span>def <span class="ident">commutes_with</span></span>(<span>self, gate: <a title="hybridq.dm.gate.property.Map" href="#hybridq.dm.gate.property.Map">Map</a>, atol: float = 1e-07)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def commutes_with(self, gate: Map, atol: float = 1e-7):
    from hybridq.gate import MatrixGate

    # Gate must be a map
    if not isinstance(gate, Map):
        raise ValueError(
            f&#34;Cannot compute commutation between &#39;Map&#39; and &#39;{type(gate).__name__}&#39;&#34;
        )

    # Get gates
    g1 = MatrixGate(self.Matrix,
                    qubits=[(0, q) for q in self.l_qubits] +
                    [(1, q) for q in self.r_qubits],
                    copy=False)
    g2 = MatrixGate(gate.Matrix,
                    qubits=[(0, q) for q in gate.l_qubits] +
                    [(1, q) for q in gate.r_qubits],
                    copy=False)

    # Return if they commute
    return g1.commutes_with(g2, atol=atol)</code></pre>
</details>
</dd>
<dt id="hybridq.dm.gate.property.Map.isclose"><code class="name flex">
<span>def <span class="ident">isclose</span></span>(<span>self, gate: <a title="hybridq.dm.gate.property.Map" href="#hybridq.dm.gate.property.Map">Map</a>, atol: float = 1e-08)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isclose(self, gate: Map, atol: float = 1e-8):

    # If gate is not a SuperGate or they qubits differ, they are different
    if not isinstance(gate, Map) or self.qubits != gate.qubits:
        return False

    # Get matrices
    _U1 = self.map(order=self.qubits)
    _U2 = gate.map(order=self.qubits)

    # Check
    return np.allclose(_U1, _U2, atol=atol)</code></pre>
</details>
</dd>
<dt id="hybridq.dm.gate.property.Map.map"><code class="name flex">
<span>def <span class="ident">map</span></span>(<span>self, order: iter[any] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return map.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>order</code></strong> :&ensp;<code>tuple[any, &hellip;]</code>, optional</dt>
<dd>If provided, Kraus' map is ordered accordingly to <code>order</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map(self, order: iter[any] = None):
    &#34;&#34;&#34;
    Return map.

    Parameters
    ----------
    order: tuple[any, ...], optional
        If provided, Kraus&#39; map is ordered accordingly to `order`.
    &#34;&#34;&#34;
    # Get left and right qubits
    l_qubits, r_qubits = self.qubits

    # Get order
    if order is not None:
        from hybridq.utils import sort

        # Get order
        order = tuple(order)

        try:
            # Split
            l_order, r_order = order

            # Convert to tuples
            l_order = tuple(l_order)
            r_order = tuple(r_order)

            # Check that qubits are consistent
            if sort(l_order) != sort(l_qubits) or sort(r_order) != sort(
                    r_qubits):
                raise RuntimeError(&#34;Something went wrong.&#34;)

            # Get order
            order = (l_order, r_order)
        except:
            if l_qubits != r_qubits or sort(order) != sort(l_qubits):
                raise ValueError(
                    &#34;&#39;order&#39; is not a valid permutation of qubits.&#34;)

            # Get order
            order = (order, order)

    # Get Matrix representing the map
    _U = self.Matrix

    # Transpose if order is provided
    if order is not None and (order[0] != self.l_qubits or
                              order[1] != self.r_qubits):
        from hybridq.gate import MatrixGate

        # Get gate
        _g = MatrixGate(_U,
                        qubits=tuple((0, q) for q in l_qubits) + tuple(
                            (1, q) for q in r_qubits),
                        copy=False)

        # Transpose
        _U = _g.matrix(order=tuple((0, q) for q in order[0]) + tuple(
            (1, q) for q in order[1]))

    # Return map
    return _U</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="hybridq.dm.gate" href="index.html">hybridq.dm.gate</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="hybridq.dm.gate.property.BaseTupleSuperGate" href="#hybridq.dm.gate.property.BaseTupleSuperGate">BaseTupleSuperGate</a></code></h4>
<ul class="">
<li><code><a title="hybridq.dm.gate.property.BaseTupleSuperGate.n_qubits" href="#hybridq.dm.gate.property.BaseTupleSuperGate.n_qubits">n_qubits</a></code></li>
<li><code><a title="hybridq.dm.gate.property.BaseTupleSuperGate.qubits" href="#hybridq.dm.gate.property.BaseTupleSuperGate.qubits">qubits</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hybridq.dm.gate.property.Map" href="#hybridq.dm.gate.property.Map">Map</a></code></h4>
<ul class="">
<li><code><a title="hybridq.dm.gate.property.Map.commutes_with" href="#hybridq.dm.gate.property.Map.commutes_with">commutes_with</a></code></li>
<li><code><a title="hybridq.dm.gate.property.Map.isclose" href="#hybridq.dm.gate.property.Map.isclose">isclose</a></code></li>
<li><code><a title="hybridq.dm.gate.property.Map.map" href="#hybridq.dm.gate.property.Map.map">map</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>