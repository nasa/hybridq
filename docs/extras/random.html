<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>hybridq.extras.random API documentation</title>
<meta name="description" content="Author: Salvatore Mandra (salvatore.mandra@nasa.gov) …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>hybridq.extras.random</code></h1>
</header>
<section id="section-intro">
<p>Author: Salvatore Mandra (salvatore.mandra@nasa.gov)</p>
<p>Copyright © 2021, United States Government, as represented by the Administrator
of the National Aeronautics and Space Administration. All rights reserved.</p>
<p>The HybridQ: A Hybrid Simulator for Quantum Circuits platform is licensed under
the Apache License, Version 2.0 (the "License"); you may not use this file
except in compliance with the License. You may obtain a copy of the License at
<a href="http://www.apache.org/licenses/LICENSE-2.0.">http://www.apache.org/licenses/LICENSE-2.0.</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed
under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Author: Salvatore Mandra (salvatore.mandra@nasa.gov)

Copyright © 2021, United States Government, as represented by the Administrator
of the National Aeronautics and Space Administration. All rights reserved.

The HybridQ: A Hybrid Simulator for Quantum Circuits platform is licensed under
the Apache License, Version 2.0 (the &#34;License&#34;); you may not use this file
except in compliance with the License. You may obtain a copy of the License at
http://www.apache.org/licenses/LICENSE-2.0.

Unless required by applicable law or agreed to in writing, software distributed
under the License is distributed on an &#34;AS IS&#34; BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.
&#34;&#34;&#34;

from __future__ import annotations
from hybridq.gate.utils import get_available_gates, get_clifford_gates
from hybridq.gate import Gate, MatrixGate
from hybridq.circuit import Circuit
import numpy as np


def get_indexes(n_qubits: int, *, use_random_indexes: bool = False):
    # Initialize
    indexes = []

    # Randomize indexes
    if use_random_indexes:

        # Add strings
        indexes = []
        while len(indexes) &lt; n_qubits // 3:
            indexes += [
                &#39;&#39;.join(
                    np.random.choice(list(&#39;abcdefghijklmnopqrstuvwxyz&#39;),
                                     size=20))
                for _ in range(n_qubits // 3 - len(indexes))
            ]

        # Add tuples
        while len(indexes) &lt; n_qubits:
            indexes += [
                tuple(x) for x in np.unique(np.random.randint(
                    -2**32 + 1, 2**32 - 1, size=(n_qubits - len(indexes), 2)),
                                            axis=0)
            ]

        # Random permutation
        indexes = [indexes[i] for i in np.random.permutation(n_qubits)]

    # Use sequential
    else:
        indexes = np.arange(n_qubits)

    # Return indexes
    return indexes


def get_random_gate(randomize_power: bool = True,
                    use_clifford_only: bool = False,
                    use_unitary_only: bool = True):
    &#34;&#34;&#34;
    Generate random gate.
    &#34;&#34;&#34;
    # Get available gates
    avail_gates = get_clifford_gates(
    ) if use_clifford_only else get_available_gates()

    # Add random matrices
    if not use_unitary_only:
        avail_gates = avail_gates + (&#39;RANDOM_MATRIX&#39;,)

    # Get random gate
    gate_name = np.random.choice(avail_gates)

    # Generate a random matrix
    if gate_name == &#39;RANDOM_MATRIX&#39;:
        # Get random number of qubits
        n_qubits = np.random.choice(range(1, 3))

        # Get random matrix
        M = 2 * np.random.random(
            (2**n_qubits, 2**n_qubits)).astype(&#39;complex&#39;) - 1
        M += 1j * (2 * np.random.random((2**n_qubits, 2**n_qubits)) - 1)
        M /= 2

        # Get gate
        gate = MatrixGate(M)

    # Generate named gate
    else:
        gate = Gate(gate_name)

    # Apply random parameters if present
    if gate.provides(&#39;params&#39;):
        gate._set_params(np.random.random(size=gate.n_params))

    # Apply random power
    gate = gate**(2 * np.random.random() - 1 if randomize_power else 1)

    # Apply conjugation if supported
    if gate.provides(&#39;conj&#39;) and np.random.random() &lt; 0.5:
        gate._conj()

    # Apply transposition if supported
    if gate.provides(&#39;T&#39;) and np.random.random() &lt; 0.5:
        gate._T()

    # Convert to MatrixGate half of the times
    gate = gate if gate.name == &#39;MATRIX&#39; or np.random.random(
    ) &lt; 0.5 else MatrixGate(gate.matrix())

    # Return gate
    return gate


def get_rqc(n_qubits: int,
            n_gates: int,
            *,
            indexes: list[int] = None,
            randomize_power: bool = True,
            use_clifford_only: bool = False,
            use_unitary_only: bool = True,
            use_random_indexes: bool = False,
            verbose: bool = False):
    &#34;&#34;&#34;
  Generate random quantum circuit.
  &#34;&#34;&#34;
    from tqdm.auto import tqdm

    # Initialize circuit
    circuit = Circuit()

    # If not provided, generate indexes
    indexes = get_indexes(n_qubits, use_random_indexes=use_random_indexes
                         ) if indexes is None else list(indexes)

    # Check that size is correct
    assert (len(indexes) == n_qubits)

    # Get random gates
    gates = (get_random_gate(randomize_power=randomize_power,
                             use_unitary_only=use_unitary_only,
                             use_clifford_only=use_clifford_only)
             for _ in range(n_gates))

    # Assign random qubits, and return circuit
    return Circuit(
        gate.on([
            indexes[i]
            for i in np.random.choice(n_qubits, gate.n_qubits, replace=False)
        ])
        for gate in tqdm(gates,
                         disable=not verbose,
                         total=n_gates,
                         desc=&#39;Generating random circuit&#39;))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="hybridq.extras.random.get_indexes"><code class="name flex">
<span>def <span class="ident">get_indexes</span></span>(<span>n_qubits: int, *, use_random_indexes: bool = False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_indexes(n_qubits: int, *, use_random_indexes: bool = False):
    # Initialize
    indexes = []

    # Randomize indexes
    if use_random_indexes:

        # Add strings
        indexes = []
        while len(indexes) &lt; n_qubits // 3:
            indexes += [
                &#39;&#39;.join(
                    np.random.choice(list(&#39;abcdefghijklmnopqrstuvwxyz&#39;),
                                     size=20))
                for _ in range(n_qubits // 3 - len(indexes))
            ]

        # Add tuples
        while len(indexes) &lt; n_qubits:
            indexes += [
                tuple(x) for x in np.unique(np.random.randint(
                    -2**32 + 1, 2**32 - 1, size=(n_qubits - len(indexes), 2)),
                                            axis=0)
            ]

        # Random permutation
        indexes = [indexes[i] for i in np.random.permutation(n_qubits)]

    # Use sequential
    else:
        indexes = np.arange(n_qubits)

    # Return indexes
    return indexes</code></pre>
</details>
</dd>
<dt id="hybridq.extras.random.get_random_gate"><code class="name flex">
<span>def <span class="ident">get_random_gate</span></span>(<span>randomize_power: bool = True, use_clifford_only: bool = False, use_unitary_only: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate random gate.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_random_gate(randomize_power: bool = True,
                    use_clifford_only: bool = False,
                    use_unitary_only: bool = True):
    &#34;&#34;&#34;
    Generate random gate.
    &#34;&#34;&#34;
    # Get available gates
    avail_gates = get_clifford_gates(
    ) if use_clifford_only else get_available_gates()

    # Add random matrices
    if not use_unitary_only:
        avail_gates = avail_gates + (&#39;RANDOM_MATRIX&#39;,)

    # Get random gate
    gate_name = np.random.choice(avail_gates)

    # Generate a random matrix
    if gate_name == &#39;RANDOM_MATRIX&#39;:
        # Get random number of qubits
        n_qubits = np.random.choice(range(1, 3))

        # Get random matrix
        M = 2 * np.random.random(
            (2**n_qubits, 2**n_qubits)).astype(&#39;complex&#39;) - 1
        M += 1j * (2 * np.random.random((2**n_qubits, 2**n_qubits)) - 1)
        M /= 2

        # Get gate
        gate = MatrixGate(M)

    # Generate named gate
    else:
        gate = Gate(gate_name)

    # Apply random parameters if present
    if gate.provides(&#39;params&#39;):
        gate._set_params(np.random.random(size=gate.n_params))

    # Apply random power
    gate = gate**(2 * np.random.random() - 1 if randomize_power else 1)

    # Apply conjugation if supported
    if gate.provides(&#39;conj&#39;) and np.random.random() &lt; 0.5:
        gate._conj()

    # Apply transposition if supported
    if gate.provides(&#39;T&#39;) and np.random.random() &lt; 0.5:
        gate._T()

    # Convert to MatrixGate half of the times
    gate = gate if gate.name == &#39;MATRIX&#39; or np.random.random(
    ) &lt; 0.5 else MatrixGate(gate.matrix())

    # Return gate
    return gate</code></pre>
</details>
</dd>
<dt id="hybridq.extras.random.get_rqc"><code class="name flex">
<span>def <span class="ident">get_rqc</span></span>(<span>n_qubits: int, n_gates: int, *, indexes: list[int] = None, randomize_power: bool = True, use_clifford_only: bool = False, use_unitary_only: bool = True, use_random_indexes: bool = False, verbose: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate random quantum circuit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_rqc(n_qubits: int,
            n_gates: int,
            *,
            indexes: list[int] = None,
            randomize_power: bool = True,
            use_clifford_only: bool = False,
            use_unitary_only: bool = True,
            use_random_indexes: bool = False,
            verbose: bool = False):
    &#34;&#34;&#34;
  Generate random quantum circuit.
  &#34;&#34;&#34;
    from tqdm.auto import tqdm

    # Initialize circuit
    circuit = Circuit()

    # If not provided, generate indexes
    indexes = get_indexes(n_qubits, use_random_indexes=use_random_indexes
                         ) if indexes is None else list(indexes)

    # Check that size is correct
    assert (len(indexes) == n_qubits)

    # Get random gates
    gates = (get_random_gate(randomize_power=randomize_power,
                             use_unitary_only=use_unitary_only,
                             use_clifford_only=use_clifford_only)
             for _ in range(n_gates))

    # Assign random qubits, and return circuit
    return Circuit(
        gate.on([
            indexes[i]
            for i in np.random.choice(n_qubits, gate.n_qubits, replace=False)
        ])
        for gate in tqdm(gates,
                         disable=not verbose,
                         total=n_gates,
                         desc=&#39;Generating random circuit&#39;))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="hybridq.extras" href="index.html">hybridq.extras</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="hybridq.extras.random.get_indexes" href="#hybridq.extras.random.get_indexes">get_indexes</a></code></li>
<li><code><a title="hybridq.extras.random.get_random_gate" href="#hybridq.extras.random.get_random_gate">get_random_gate</a></code></li>
<li><code><a title="hybridq.extras.random.get_rqc" href="#hybridq.extras.random.get_rqc">get_rqc</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>