<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>hybridq.gate.utils API documentation</title>
<meta name="description" content="Author: Salvatore Mandra (salvatore.mandra@nasa.gov) …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>hybridq.gate.utils</code></h1>
</header>
<section id="section-intro">
<p>Author: Salvatore Mandra (salvatore.mandra@nasa.gov)</p>
<p>Copyright © 2021, United States Government, as represented by the Administrator
of the National Aeronautics and Space Administration. All rights reserved.</p>
<p>The HybridQ: A Hybrid Simulator for Quantum Circuits platform is licensed under
the Apache License, Version 2.0 (the "License"); you may not use this file
except in compliance with the License. You may obtain a copy of the License at
<a href="http://www.apache.org/licenses/LICENSE-2.0.">http://www.apache.org/licenses/LICENSE-2.0.</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed
under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Author: Salvatore Mandra (salvatore.mandra@nasa.gov)

Copyright © 2021, United States Government, as represented by the Administrator
of the National Aeronautics and Space Administration. All rights reserved.

The HybridQ: A Hybrid Simulator for Quantum Circuits platform is licensed under
the Apache License, Version 2.0 (the &#34;License&#34;); you may not use this file
except in compliance with the License. You may obtain a copy of the License at
http://www.apache.org/licenses/LICENSE-2.0.

Unless required by applicable law or agreed to in writing, software distributed
under the License is distributed on an &#34;AS IS&#34; BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.
&#34;&#34;&#34;

from __future__ import annotations
from hybridq.gate import Gate
import numpy as np


def get_available_gates() -&gt; tuple[str, ...]:
    &#34;&#34;&#34;
    Return available gates.
    &#34;&#34;&#34;
    from hybridq.gate.gate import _available_gates
    return tuple(_available_gates)


def get_clifford_gates() -&gt; tuple[str, ...]:
    &#34;&#34;&#34;
    Return available Clifford gates.
    &#34;&#34;&#34;
    from hybridq.gate.gate import _available_gates
    from hybridq.gate.property import CliffordGate
    return tuple(
        k for k, v in _available_gates.items() if CliffordGate in v[&#39;mro&#39;])


def merge(a: Gate, *bs) -&gt; Gate:
    &#34;&#34;&#34;
    Merge two gates `a` and `b`. The merged `Gate` will be equivalent to apply
    ```
    new_psi = bs.matrix() @ ... @ b.matrix() @ a.matrix() @ psi
    ```
    with `psi` a quantum state.

    Parameters
    ----------
    a, ...: Gate
        `Gate`s to merge.
    qubits_order: iter[any], optional
        If provided, qubits in new `Gate` will be sorted using `qubits_order`.

    Returns
    -------
    Gate(&#39;MATRIX&#39;)
        The merged `Gate`
    &#34;&#34;&#34;
    # If no other gates are provided, return
    if len(bs) == 0:
        return a

    # Pop first gate
    b, bs = bs[0], bs[1:]

    # Check
    if any(not x.provides([&#39;matrix&#39;, &#39;qubits&#39;]) or x.qubits is None
           for x in [a, b]):
        raise ValueError(
            &#34;Both &#39;a&#39; and &#39;b&#39; must provides &#39;qubits&#39; and &#39;matrix&#39;.&#34;)

    # Get unitaries
    Ua, Ub = a.matrix(), b.matrix()

    # Get shared qubits
    shared_qubits = set(a.qubits).intersection(b.qubits)
    all_qubits = b.qubits + tuple(q for q in a.qubits if q not in b.qubits)

    # Get sizes
    n_a = len(a.qubits)
    n_b = len(b.qubits)
    n_ab = len(shared_qubits)
    n_c = len(all_qubits)

    if shared_qubits:
        from opt_einsum import get_symbol, contract
        # Build map
        _map_b_l = &#39;&#39;.join(get_symbol(x) for x in range(n_b))
        _map_b_r = &#39;&#39;.join(get_symbol(x + n_b) for x in range(n_b))
        _map_a_l = &#39;&#39;.join(_map_b_r[b.qubits.index(q)] if q in
                           shared_qubits else get_symbol(x + 2 * n_b)
                           for x, q in enumerate(a.qubits))
        _map_a_r = &#39;&#39;.join(get_symbol(x + 2 * n_b + n_a) for x in range(n_a))
        _map_c_l = &#39;&#39;.join(_map_b_l[b.qubits.index(q)] if q in
                           b.qubits else _map_a_l[a.qubits.index(q)]
                           for q in all_qubits)
        _map_c_r = &#39;&#39;.join(
            _map_b_r[b.qubits.index(q)] if q in b.qubits and
            q not in shared_qubits else _map_a_r[a.qubits.index(q)]
            for q in all_qubits)
        _map = _map_b_l + _map_b_r + &#39;,&#39; + _map_a_l + _map_a_r + &#39;-&gt;&#39; + _map_c_l + _map_c_r

        # Get matrix
        U = np.reshape(
            contract(_map, np.reshape(Ub, (2,) * 2 * n_b),
                     np.reshape(Ua, (2,) * 2 * n_a)), (2**n_c, 2**n_c))
    else:
        # Get matrix
        U = np.kron(Ub, Ua)

    # Get merged gate
    gate = Gate(&#39;MATRIX&#39;, qubits=all_qubits, U=U)

    # Iteratively call merge
    if len(bs) == 0:
        return gate
    else:
        return merge(gate, *bs)


def pad(gate: Gate,
        qubits: iter[any],
        order: iter[any] = None,
        return_matrix_only: bool = False) -&gt; {MatrixGate, np.ndarray}:
    &#34;&#34;&#34;
    Pad `gate` to act on `qubits`. More precisely, if `gate` is acting on a
    subset of `qubits`, extend `gate` with identities to act on all `qubits`.

    Parameters
    ----------
    gate: Gate
        The gate to pad.
    qubits: iter[any]
        Qubits used to pad `gate`. If `gate.qubits` is not a subset of
        `qubits`, raise an error.
    order: iter[any], optional
        If provided, reorder qubits in the final gate accordingly to `qubits`.
    return_matrix_only: bool, optional
        If `True`, the matrix representing the state is returned instead of
        `MatrixGate` (default: `False`).

    Returns
    -------
    MatrixGate
        The padded gate acting on `qubits`.
    &#34;&#34;&#34;
    from hybridq.gate import MatrixGate
    from hybridq.utils import sort

    # Convert qubits to tuple
    qubits = tuple(qubits)

    # Convert order to tuple if provided
    order = None if order is None else tuple(order)

    # Check that order is a permutation of qubits
    if order and sort(qubits) != sort(order):
        raise ValueError(&#34;&#39;order&#39; must be a permutation of &#39;qubits&#39;&#34;)

    # &#39;gate&#39; must have qubits and it must be a subset of &#39;qubits&#39;
    if not gate.provides(&#39;qubits&#39;) or set(gate.qubits).difference(qubits):
        raise ValueError(&#34;&#39;gate&#39; must provide qubits and those &#34;
                         &#34;qubits must be a subset of &#39;qubits&#39;.&#34;)

    # Get matrix
    M = gate.matrix()

    # Pad matrix with identity
    if gate.n_qubits != len(qubits):
        M = np.kron(M, np.eye(2**(len(qubits) - gate.n_qubits)))

    # Get new qubits
    qubits = gate.qubits + tuple(set(qubits).difference(gate.qubits))

    # Reorder if required
    if order and order != qubits:
        # Get new matrix
        M = MatrixGate(M, qubits=qubits).matrix(order=order)

        # Set new qubits
        qubits = order

    # Return gate
    return M if return_matrix_only else MatrixGate(
        M, qubits=qubits, tags=gate.tags if gate.provides(&#39;tags&#39;) else {})


def decompose(gate: Gate,
              qubits: iter[any],
              return_matrices: bool = False,
              atol: float = 1e-8) -&gt; SchmidtGate:
    &#34;&#34;&#34;
    Decompose `gate` using the Schmidt decomposition.

    Parameters
    ----------
    gate: Gate
        `Gate` to decompose.
    qubits: iter[any]
        Subset of qubits used to decompose `gate`.
    return_matrices: bool, optional
        If `True`, return matrices instead of gates (default: `False`)
    atol: float
        Tollerance.

    Returns
    -------
    d: tuple(list[float], tuple[Gate, ...], tuple[Gate, ...])
        Decomposition of `gate`.

    See Also
    --------
    `hybridq.utils.svd`
    &#34;&#34;&#34;
    from hybridq.gate import SchmidtGate
    from hybridq.utils import svd

    # Check qubits
    try:
        qubits = tuple(qubits)
    except:
        raise ValueError(&#34;&#39;qubits&#39; must be convertible to tuple.&#34;)

    # Get number of qubits in subset
    ns = len(qubits)

    # Get qubits not in subset
    alt_qubits = tuple(q for q in gate.qubits if q not in qubits)

    # Check is valid subset
    if set(qubits).difference(gate.qubits):
        raise ValueError(&#34;&#39;qubits&#39; must be a valid subset of `gate.qubits`.&#34;)

    # Get order
    axes = [gate.qubits.index(x) for x in qubits]
    axes += [x + gate.n_qubits for x in axes]

    # Get matrix and decompose it
    s, uh, vh = svd(np.reshape(gate.matrix(), (2,) * 2 * gate.n_qubits),
                    axes,
                    atol=atol)

    # Reshape
    uh = np.reshape(uh, (len(s), 2**ns, 2**ns))
    vh = np.reshape(vh,
                    (len(s), 2**(gate.n_qubits - ns), 2**(gate.n_qubits - ns)))

    # Return gates
    return (s, uh, vh) if return_matrices else SchmidtGate(
        gates=((Gate(&#39;MATRIX&#39;, qubits=qubits, U=x) for x in uh),
               (Gate(&#39;MATRIX&#39;, qubits=alt_qubits, U=x) for x in vh)),
        s=s)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="hybridq.gate.utils.decompose"><code class="name flex">
<span>def <span class="ident">decompose</span></span>(<span>gate: Gate, qubits: iter[any], return_matrices: bool = False, atol: float = 1e-08) ‑> SchmidtGate</span>
</code></dt>
<dd>
<div class="desc"><p>Decompose <code>gate</code> using the Schmidt decomposition.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>gate</code></strong> :&ensp;<code>Gate</code></dt>
<dd><code>Gate</code> to decompose.</dd>
<dt><strong><code>qubits</code></strong> :&ensp;<code>iter[any]</code></dt>
<dd>Subset of qubits used to decompose <code>gate</code>.</dd>
<dt><strong><code>return_matrices</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, return matrices instead of gates (default: <code>False</code>)</dd>
<dt><strong><code>atol</code></strong> :&ensp;<code>float</code></dt>
<dd>Tollerance.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>d</code></strong> :&ensp;<code>tuple(list[float], tuple[Gate, &hellip;], tuple[Gate, &hellip;])</code></dt>
<dd>Decomposition of <code>gate</code>.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code>hybridq.utils.svd</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decompose(gate: Gate,
              qubits: iter[any],
              return_matrices: bool = False,
              atol: float = 1e-8) -&gt; SchmidtGate:
    &#34;&#34;&#34;
    Decompose `gate` using the Schmidt decomposition.

    Parameters
    ----------
    gate: Gate
        `Gate` to decompose.
    qubits: iter[any]
        Subset of qubits used to decompose `gate`.
    return_matrices: bool, optional
        If `True`, return matrices instead of gates (default: `False`)
    atol: float
        Tollerance.

    Returns
    -------
    d: tuple(list[float], tuple[Gate, ...], tuple[Gate, ...])
        Decomposition of `gate`.

    See Also
    --------
    `hybridq.utils.svd`
    &#34;&#34;&#34;
    from hybridq.gate import SchmidtGate
    from hybridq.utils import svd

    # Check qubits
    try:
        qubits = tuple(qubits)
    except:
        raise ValueError(&#34;&#39;qubits&#39; must be convertible to tuple.&#34;)

    # Get number of qubits in subset
    ns = len(qubits)

    # Get qubits not in subset
    alt_qubits = tuple(q for q in gate.qubits if q not in qubits)

    # Check is valid subset
    if set(qubits).difference(gate.qubits):
        raise ValueError(&#34;&#39;qubits&#39; must be a valid subset of `gate.qubits`.&#34;)

    # Get order
    axes = [gate.qubits.index(x) for x in qubits]
    axes += [x + gate.n_qubits for x in axes]

    # Get matrix and decompose it
    s, uh, vh = svd(np.reshape(gate.matrix(), (2,) * 2 * gate.n_qubits),
                    axes,
                    atol=atol)

    # Reshape
    uh = np.reshape(uh, (len(s), 2**ns, 2**ns))
    vh = np.reshape(vh,
                    (len(s), 2**(gate.n_qubits - ns), 2**(gate.n_qubits - ns)))

    # Return gates
    return (s, uh, vh) if return_matrices else SchmidtGate(
        gates=((Gate(&#39;MATRIX&#39;, qubits=qubits, U=x) for x in uh),
               (Gate(&#39;MATRIX&#39;, qubits=alt_qubits, U=x) for x in vh)),
        s=s)</code></pre>
</details>
</dd>
<dt id="hybridq.gate.utils.get_available_gates"><code class="name flex">
<span>def <span class="ident">get_available_gates</span></span>(<span>) ‑> tuple[str, ...]</span>
</code></dt>
<dd>
<div class="desc"><p>Return available gates.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_available_gates() -&gt; tuple[str, ...]:
    &#34;&#34;&#34;
    Return available gates.
    &#34;&#34;&#34;
    from hybridq.gate.gate import _available_gates
    return tuple(_available_gates)</code></pre>
</details>
</dd>
<dt id="hybridq.gate.utils.get_clifford_gates"><code class="name flex">
<span>def <span class="ident">get_clifford_gates</span></span>(<span>) ‑> tuple[str, ...]</span>
</code></dt>
<dd>
<div class="desc"><p>Return available Clifford gates.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_clifford_gates() -&gt; tuple[str, ...]:
    &#34;&#34;&#34;
    Return available Clifford gates.
    &#34;&#34;&#34;
    from hybridq.gate.gate import _available_gates
    from hybridq.gate.property import CliffordGate
    return tuple(
        k for k, v in _available_gates.items() if CliffordGate in v[&#39;mro&#39;])</code></pre>
</details>
</dd>
<dt id="hybridq.gate.utils.merge"><code class="name flex">
<span>def <span class="ident">merge</span></span>(<span>a: Gate, *bs) ‑> <function Gate at 0x7f2f047384d0></span>
</code></dt>
<dd>
<div class="desc"><p>Merge two gates <code>a</code> and <code>b</code>. The merged <code>Gate</code> will be equivalent to apply</p>
<pre><code>new_psi = bs.matrix() @ ... @ b.matrix() @ a.matrix() @ psi
</code></pre>
<p>with <code>psi</code> a quantum state.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>a, &hellip;: Gate</dt>
<dt><code>Gate</code>s to merge.</dt>
<dt><strong><code>qubits_order</code></strong> :&ensp;<code>iter[any]</code>, optional</dt>
<dd>If provided, qubits in new <code>Gate</code> will be sorted using <code>qubits_order</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Gate('MATRIX')</code></dt>
<dd>The merged <code>Gate</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge(a: Gate, *bs) -&gt; Gate:
    &#34;&#34;&#34;
    Merge two gates `a` and `b`. The merged `Gate` will be equivalent to apply
    ```
    new_psi = bs.matrix() @ ... @ b.matrix() @ a.matrix() @ psi
    ```
    with `psi` a quantum state.

    Parameters
    ----------
    a, ...: Gate
        `Gate`s to merge.
    qubits_order: iter[any], optional
        If provided, qubits in new `Gate` will be sorted using `qubits_order`.

    Returns
    -------
    Gate(&#39;MATRIX&#39;)
        The merged `Gate`
    &#34;&#34;&#34;
    # If no other gates are provided, return
    if len(bs) == 0:
        return a

    # Pop first gate
    b, bs = bs[0], bs[1:]

    # Check
    if any(not x.provides([&#39;matrix&#39;, &#39;qubits&#39;]) or x.qubits is None
           for x in [a, b]):
        raise ValueError(
            &#34;Both &#39;a&#39; and &#39;b&#39; must provides &#39;qubits&#39; and &#39;matrix&#39;.&#34;)

    # Get unitaries
    Ua, Ub = a.matrix(), b.matrix()

    # Get shared qubits
    shared_qubits = set(a.qubits).intersection(b.qubits)
    all_qubits = b.qubits + tuple(q for q in a.qubits if q not in b.qubits)

    # Get sizes
    n_a = len(a.qubits)
    n_b = len(b.qubits)
    n_ab = len(shared_qubits)
    n_c = len(all_qubits)

    if shared_qubits:
        from opt_einsum import get_symbol, contract
        # Build map
        _map_b_l = &#39;&#39;.join(get_symbol(x) for x in range(n_b))
        _map_b_r = &#39;&#39;.join(get_symbol(x + n_b) for x in range(n_b))
        _map_a_l = &#39;&#39;.join(_map_b_r[b.qubits.index(q)] if q in
                           shared_qubits else get_symbol(x + 2 * n_b)
                           for x, q in enumerate(a.qubits))
        _map_a_r = &#39;&#39;.join(get_symbol(x + 2 * n_b + n_a) for x in range(n_a))
        _map_c_l = &#39;&#39;.join(_map_b_l[b.qubits.index(q)] if q in
                           b.qubits else _map_a_l[a.qubits.index(q)]
                           for q in all_qubits)
        _map_c_r = &#39;&#39;.join(
            _map_b_r[b.qubits.index(q)] if q in b.qubits and
            q not in shared_qubits else _map_a_r[a.qubits.index(q)]
            for q in all_qubits)
        _map = _map_b_l + _map_b_r + &#39;,&#39; + _map_a_l + _map_a_r + &#39;-&gt;&#39; + _map_c_l + _map_c_r

        # Get matrix
        U = np.reshape(
            contract(_map, np.reshape(Ub, (2,) * 2 * n_b),
                     np.reshape(Ua, (2,) * 2 * n_a)), (2**n_c, 2**n_c))
    else:
        # Get matrix
        U = np.kron(Ub, Ua)

    # Get merged gate
    gate = Gate(&#39;MATRIX&#39;, qubits=all_qubits, U=U)

    # Iteratively call merge
    if len(bs) == 0:
        return gate
    else:
        return merge(gate, *bs)</code></pre>
</details>
</dd>
<dt id="hybridq.gate.utils.pad"><code class="name flex">
<span>def <span class="ident">pad</span></span>(<span>gate: Gate, qubits: iter[any], order: iter[any] = None, return_matrix_only: bool = False) ‑> {MatrixGate, np.ndarray}</span>
</code></dt>
<dd>
<div class="desc"><p>Pad <code>gate</code> to act on <code>qubits</code>. More precisely, if <code>gate</code> is acting on a
subset of <code>qubits</code>, extend <code>gate</code> with identities to act on all <code>qubits</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>gate</code></strong> :&ensp;<code>Gate</code></dt>
<dd>The gate to pad.</dd>
<dt><strong><code>qubits</code></strong> :&ensp;<code>iter[any]</code></dt>
<dd>Qubits used to pad <code>gate</code>. If <code>gate.qubits</code> is not a subset of
<code>qubits</code>, raise an error.</dd>
<dt><strong><code>order</code></strong> :&ensp;<code>iter[any]</code>, optional</dt>
<dd>If provided, reorder qubits in the final gate accordingly to <code>qubits</code>.</dd>
<dt><strong><code>return_matrix_only</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, the matrix representing the state is returned instead of
<code>MatrixGate</code> (default: <code>False</code>).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>MatrixGate</code></dt>
<dd>The padded gate acting on <code>qubits</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pad(gate: Gate,
        qubits: iter[any],
        order: iter[any] = None,
        return_matrix_only: bool = False) -&gt; {MatrixGate, np.ndarray}:
    &#34;&#34;&#34;
    Pad `gate` to act on `qubits`. More precisely, if `gate` is acting on a
    subset of `qubits`, extend `gate` with identities to act on all `qubits`.

    Parameters
    ----------
    gate: Gate
        The gate to pad.
    qubits: iter[any]
        Qubits used to pad `gate`. If `gate.qubits` is not a subset of
        `qubits`, raise an error.
    order: iter[any], optional
        If provided, reorder qubits in the final gate accordingly to `qubits`.
    return_matrix_only: bool, optional
        If `True`, the matrix representing the state is returned instead of
        `MatrixGate` (default: `False`).

    Returns
    -------
    MatrixGate
        The padded gate acting on `qubits`.
    &#34;&#34;&#34;
    from hybridq.gate import MatrixGate
    from hybridq.utils import sort

    # Convert qubits to tuple
    qubits = tuple(qubits)

    # Convert order to tuple if provided
    order = None if order is None else tuple(order)

    # Check that order is a permutation of qubits
    if order and sort(qubits) != sort(order):
        raise ValueError(&#34;&#39;order&#39; must be a permutation of &#39;qubits&#39;&#34;)

    # &#39;gate&#39; must have qubits and it must be a subset of &#39;qubits&#39;
    if not gate.provides(&#39;qubits&#39;) or set(gate.qubits).difference(qubits):
        raise ValueError(&#34;&#39;gate&#39; must provide qubits and those &#34;
                         &#34;qubits must be a subset of &#39;qubits&#39;.&#34;)

    # Get matrix
    M = gate.matrix()

    # Pad matrix with identity
    if gate.n_qubits != len(qubits):
        M = np.kron(M, np.eye(2**(len(qubits) - gate.n_qubits)))

    # Get new qubits
    qubits = gate.qubits + tuple(set(qubits).difference(gate.qubits))

    # Reorder if required
    if order and order != qubits:
        # Get new matrix
        M = MatrixGate(M, qubits=qubits).matrix(order=order)

        # Set new qubits
        qubits = order

    # Return gate
    return M if return_matrix_only else MatrixGate(
        M, qubits=qubits, tags=gate.tags if gate.provides(&#39;tags&#39;) else {})</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="hybridq.gate" href="index.html">hybridq.gate</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="hybridq.gate.utils.decompose" href="#hybridq.gate.utils.decompose">decompose</a></code></li>
<li><code><a title="hybridq.gate.utils.get_available_gates" href="#hybridq.gate.utils.get_available_gates">get_available_gates</a></code></li>
<li><code><a title="hybridq.gate.utils.get_clifford_gates" href="#hybridq.gate.utils.get_clifford_gates">get_clifford_gates</a></code></li>
<li><code><a title="hybridq.gate.utils.merge" href="#hybridq.gate.utils.merge">merge</a></code></li>
<li><code><a title="hybridq.gate.utils.pad" href="#hybridq.gate.utils.pad">pad</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>